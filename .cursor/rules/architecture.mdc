---
alwaysApply: true
---

---

description: Architecture patterns, state management, routing, and best practices
globs: _.tsx, _.jsx, _.css, _.js, \*.ts

---

# Architecture Guidelines

## Type Safety

### TypeScript Configuration

- Use TypeScript for all new code
- Maintain strict type checking
- Avoid `any` types unless absolutely necessary
- Use proper type imports (`import type` when importing only types)

```tsx
import type { ComponentProps } from 'react'

interface ButtonProps extends ComponentProps<'button'> {
  variant?: 'primary' | 'secondary'
}
```

## State Management

### React Built-in State

Prefer React's built-in state for component-local state. Keep state as close to where it's used as possible.

```tsx
function Component() {
  const [count, setCount] = useState(0)
  return <button onClick={() => setCount(count + 1)}>{count}</button>
}
```

### MobX State Tree (MST) for Global State

Use MobX State Tree for global / shared state. Define store models in `@/state`.

```tsx
// @/state/CounterStore.ts
import { types } from 'mobx-state-tree'

export const CounterStore = types
  .model('CounterStore', {
    count: types.optional(types.number, 0),
  })
  .actions((self) => ({
    increment() {
      self.count += 1
    },
    decrement() {
      self.count -= 1
    },
  }))
  .views((self) => ({
    get isPositive() {
      return self.count > 0
    },
  }))
```

```tsx
// @/state/RootStore.ts
import { CounterStore } from './CounterStore'
import { types, Instance } from 'mobx-state-tree'

export const RootStore = types.model('RootStore', {
  counter: types.optional(CounterStore, {}),
})

export type IRootStore = Instance<typeof RootStore>
```

```tsx
// Provide the store via React context
import { RootStore, IRootStore } from '@/state/RootStore'
import { createContext, useContext } from 'react'

const StoreContext = createContext<IRootStore | null>(null)

export function StoreProvider({ children }: { children: React.ReactNode }) {
  const store = RootStore.create({})
  return <StoreContext.Provider value={store}>{children}</StoreContext.Provider>
}

export function useStore() {
  const store = useContext(StoreContext)
  if (!store) throw new Error('useStore must be used within a StoreProvider')
  return store
}
```

```tsx
// Use in components with observer
import { useStore } from '@/state/StoreProvider'
import { observer } from 'mobx-react-lite'

const Counter = observer(() => {
  const { counter } = useStore()
  return <button onClick={() => counter.increment()}>{counter.count}</button>
})
```

### State Management Best Practices

- Keep state minimal; derive computed values using MST `.views()`
- Wrap components that read MST observables with `observer` from `mobx-react-lite`
- Use React context for simple shared UI state (theme, modals)
- Use MST for complex domain / global state (cart, user, app settings)
- Avoid prop drilling with composition patterns

## Routing & Navigation

### React Router

Use React Router v7 with `BrowserRouter`. Routes are defined in `@/pages/AppRoutes.tsx`.

```tsx
// @/pages/AppRoutes.tsx
import { BrowserRouter, Route, Routes } from 'react-router'

export const AppRoutes = () => (
  <BrowserRouter>
    <Routes>
      <Route path="/" element={<HomePage />} />
      <Route path="/about" element={<AboutPage />} />
      <Route path="*" element={<NotFoundPage />} />
    </Routes>
  </BrowserRouter>
)
```

### Routing Best Practices

- Define all routes in `AppRoutes.tsx` for a single source of truth
- Use `<Link>` from `react-router` for internal navigation (never `<a>` tags)
- Use `useNavigate()` for programmatic navigation
- Use `useParams()` and `useSearchParams()` for reading route/query params
- Place page components in `@/pages/` — one file per route
- Use lazy loading with `React.lazy()` and `<Suspense>` for code splitting heavy pages

```tsx
import { lazy, Suspense } from 'react'
const HeavyPage = lazy(() => import('@/pages/HeavyPage'))

<Route path="/heavy" element={
  <Suspense fallback={<div>Loading…</div>}>
    <HeavyPage />
  </Suspense>
} />
```

## Code Quality

### Linting & Formatting

- Follow ES linting rules
- Run `npm run lint` before committing
- Maintain consistent code style
- Fix linting errors immediately

### Code Organization

- Follow the defined project structure
- Maintain separation of concerns
- Use meaningful variable and function names
- Write meaningful comments and documentation
- Prefer named exports for utilities

### Component Composition

Follow component composition patterns. Keep components focused and reusable.

```tsx
// Good: Composable components
function Card({ children, className }) {
  return <div className={cn(s.card, className)}>{children}</div>
}

function CardHeader({ children }) {
  return <div className={s.header}>{children}</div>
}

function CardBody({ children }) {
  return <div className={s.body}>{children}</div>
}

// Usage
;<Card>
  <CardHeader>Title</CardHeader>
  <CardBody>Content</CardBody>
</Card>
```

### Utility Functions

Always use `cn` from `clsx` for className conditionals

```tsx
import cn from 'clsx'

function MyComponent({ className }) {
  return <div className={cn(s.component, className)} />
}
```

### ShadCn Components

Use components from ShadCn located in `@/components/ui` when available

```tsx
import { Select } from '@/components/ui/card'
```

## Development Workflow

### Package Manager

Use Npm as the JavaScript runtime and package manager.

```bash
# Install dependencies
npm install

# Run development server
npm dev

# Build for production
npm run build

# Run linting
npm run lint
```

## Best Practices Summary

1. **Type Safety**: Use TypeScript everywhere, avoid `any`
2. **State Management**: React state first, MobX State Tree for global / shared needs
3. **Routing**: React Router v7 with `BrowserRouter`, routes defined in `AppRoutes.tsx`
4. **Performance**: Code split heavy pages with `React.lazy()` and `<Suspense>`
5. **Code Quality**: Follow linting rules, maintain consistent style, write meaningful documentation
6. **Development**: Use npm, follow git best practices
